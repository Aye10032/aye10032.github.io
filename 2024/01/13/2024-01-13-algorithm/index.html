<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/favicon.png"><link rel="icon" href="/images/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Aye10032"><meta name="keywords" content=""><meta name="description" content="国科大2023秋季学期卜东波算法设计与分析作业"><meta property="og:type" content="article"><meta property="og:title" content="算法设计与分析作业"><meta property="og:url" content="https://www.aye10032.com/2024/01/13/2024-01-13-algorithm/index.html"><meta property="og:site_name" content="鸽子窝"><meta property="og:description" content="国科大2023秋季学期卜东波算法设计与分析作业"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-01-13T00:00:00.000Z"><meta property="article:modified_time" content="2024-01-13T00:00:00.000Z"><meta property="article:author" content="Aye10032"><meta property="article:tag" content="学习"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@Aye10032"><meta name="referrer" content="no-referrer-when-downgrade"><title>算法设计与分析作业 - 鸽子窝</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.aye10032.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/images/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:"G-285089DP1E"},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=G-285089DP1E",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","G-285089DP1E")}))</script><meta name="generator" content="Hexo 7.0.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>鸽子窝</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/bangumis/index.html" target="_self"><i class="iconfont icon-bilibili-fill"></i> <span>我的追番</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/images/background-cover.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="算法设计与分析作业"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Aye10032 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-01-13 00:00" pubdate>2024年1月13日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 38 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="学习" id="heading-4ef520d6cd20ba4a727af08e17e4939e" role="tab" data-toggle="collapse" href="#collapse-4ef520d6cd20ba4a727af08e17e4939e" aria-expanded="true">学习 <span class="list-group-count">(15)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-4ef520d6cd20ba4a727af08e17e4939e" role="tabpanel" aria-labelledby="heading-4ef520d6cd20ba4a727af08e17e4939e"><div class="category-post-list"><a href="/2024/01/13/2024-01-13-algorithm/" title="算法设计与分析作业" class="list-group-item list-group-item-action active"><span class="category-post">算法设计与分析作业</span></a></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="unity" id="heading-439b3a25b555b3bc8667a09a036ae70c" role="tab" data-toggle="collapse" href="#collapse-439b3a25b555b3bc8667a09a036ae70c" aria-expanded="false">unity <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-439b3a25b555b3bc8667a09a036ae70c" role="tabpanel" aria-labelledby="heading-439b3a25b555b3bc8667a09a036ae70c"><div class="category-post-list"><a href="/2023/01/21/2023-01-21-Unity-Particle/" title="unity 粒子效果笔记" class="list-group-item list-group-item-action"><span class="category-post">unity 粒子效果笔记</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="期末复习" id="heading-69f506b4426d281814d067770ad53047" role="tab" data-toggle="collapse" href="#collapse-69f506b4426d281814d067770ad53047" aria-expanded="false">期末复习 <span class="list-group-count">(9)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-69f506b4426d281814d067770ad53047" role="tabpanel" aria-labelledby="heading-69f506b4426d281814d067770ad53047"><div class="category-post-list"><a href="/2018/05/20/2018-05-20-PLC/" title="PLC期末题库" class="list-group-item list-group-item-action"><span class="category-post">PLC期末题库</span> </a><a href="/2018/05/18/2018-05-18-dawu/" title="大学物理上复习笔记" class="list-group-item list-group-item-action"><span class="category-post">大学物理上复习笔记</span> </a><a href="/2023/09/27/2023-09-27-english/" title="学术论文写作规范" class="list-group-item list-group-item-action"><span class="category-post">学术论文写作规范</span> </a><a href="/2020/06/28/2020-06-28-IoT/" title="工业物联网复习" class="list-group-item list-group-item-action"><span class="category-post">工业物联网复习</span> </a><a href="/2018/05/05/2018-05-05-feC/" title="工程材料学复习笔记" class="list-group-item list-group-item-action"><span class="category-post">工程材料学复习笔记</span> </a><a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="list-group-item list-group-item-action"><span class="category-post">More...</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="机器学习" id="heading-61bb1751fd355596e307767d1927c855" role="tab" data-toggle="collapse" href="#collapse-61bb1751fd355596e307767d1927c855" aria-expanded="false">机器学习 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-61bb1751fd355596e307767d1927c855" role="tabpanel" aria-labelledby="heading-61bb1751fd355596e307767d1927c855"><div class="category-post-list"><a href="/2020/12/29/2020-12-29-CNNmodles/" title="几种经典的CNN模型" class="list-group-item list-group-item-action"><span class="category-post">几种经典的CNN模型</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="生物信息学" id="heading-9b17337cce03384cfde4fda8da0ff881" role="tab" data-toggle="collapse" href="#collapse-9b17337cce03384cfde4fda8da0ff881" aria-expanded="false">生物信息学 <span class="list-group-count">(3)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-9b17337cce03384cfde4fda8da0ff881" role="tabpanel" aria-labelledby="heading-9b17337cce03384cfde4fda8da0ff881"><div class="category-post-list"><a href="/2023/08/28/2023-08-28-sam_format/" title="sam/bam文件格式信息" class="list-group-item list-group-item-action"><span class="category-post">sam/bam文件格式信息</span> </a><a href="/2023/08/11/2023-08-11-trim_goal/" title="测序数据处理自用笔记" class="list-group-item list-group-item-action"><span class="category-post">测序数据处理自用笔记</span> </a><a href="/2023/05/24/2023-05-24-Bioinformatics/" title="生物信息学知识图谱" class="list-group-item list-group-item-action"><span class="category-post">生物信息学知识图谱</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">算法设计与分析作业</h1><div class="markdown-body"><h1 id="一分治">一、分治</h1><div class="note note-info"><p><strong>主定理</strong></p><p><span class="math display">\[T(n)=aT\left(\dfrac nb\right) + f(n^d)=\begin{cases}O(n^{\log_ba}) &amp; d&lt;\log_ba\\O(n^{\log_ba}\log n) &amp;d=\log_ba\\O(n^d)&amp;d&gt;\log_ba\end{cases}\]</span></p><p>其中：</p><ul><li>a：子问题的数量</li><li>b：子问题规模与原问题的比</li><li><span class="math inline">\(f(n^d)\)</span>：合并子问题以及除了递归调用之外的算法的时间复杂度</li></ul></div><h2 id="q1">Q1</h2><h3 id="题目">题目</h3><p>You are interested in analyzing some hard-to-obtain data from two separate databases. Each database contains n numerical values, so there are 2n values total and you may assume that no two values are the same. You’d like to determine the median of this set of 2n values, which we will define here to be the nth smallest value. However, the only way you can access these values is through queries to the databases. In a single query, you can specify a value k to one of the two databases, and the chosen database will return the kth smallest value that it contains. Since queries are expensive, you would like to compute the median using as few queries as possible. Give an algorithm that finds the median value using at most <span class="math inline">\(O(\log n)\)</span> queries.</p><h3 id="思路">思路</h3><ol type="1"><li>首先对两个数据库各取中位数<span class="math inline">\(\frac{n}{2}\)</span></li><li>比较两中位数的大小，假设其中较小的一个为M1，较大的为M2</li><li>全局中位数必然位于相应数据库中大于M1或小于M2的部分中</li><li>取这两部分作为新的数据库，再次重复上述操作</li><li>直到数据库长度为1时停止，由于本题令中位数为全局的第N个，因此这里取两个中较小的一个即为答案</li></ol><h3 id="伪代码">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">FINDMID</span>(<span class="hljs-params"><span class="hljs-built_in">len</span>, k1, k2</span>):<br>	M1 = ask(<span class="hljs-number">1</span>, k1)<br>	M2 = ask(<span class="hljs-number">2</span>, k2)<br>	<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span> == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(M1, M2)<br>    <span class="hljs-keyword">else</span>:<br>		<span class="hljs-keyword">if</span> M1&lt;M2:<br>            FINDMID(<span class="hljs-built_in">len</span>/<span class="hljs-number">2</span>, k1 + k1/<span class="hljs-number">2</span>, k2 - k2/<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">else</span>:<br>            FINDMID(<span class="hljs-built_in">len</span>/<span class="hljs-number">2</span>, k1 - k1/<span class="hljs-number">2</span>, k2 + k2/<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="时间复杂度">时间复杂度</h3><p>由于需要查询直到数据库长度为1，表现为树就是需要一直遍历到树底，则迭代次数为<span class="math inline">\(\log(n)\)</span>，每次需要进行两次查询操作，时间复杂度均为1，故总时间复杂度为 <span class="math display">\[ T(n) = T(\frac{n}{2}) + c = O(\log n) \]</span></p><h2 id="q2">Q2</h2><h3 id="题目-1">题目</h3><p>Given any 10 points, <span class="math inline">\(p_1, p_2, \dots, p_{10}\)</span>, on a two-dimensional Euclidean plane, please write an algorithm to find the distance between the closest pair of points.</p><ol type="1"><li>Using a brute-force algorithm to solve this problem, analyze the time complexity of your implemented brute-force algorithm and explain why the algorithm’s time complexity is <span class="math inline">\(O(n^2)\)</span>, where n is the number of points.</li><li>Propose an improved algorithm to solve this problem with a time complexity better than the brute-force algorithm. Describe the algorithm’s idea and analyze its time complexity.</li></ol><h3 id="暴力解">1、暴力解</h3><h4 id="思路-1">思路</h4><ol type="1"><li>遍历每一个点，计算它与其他点的距离</li><li>遍历过程中保存当前MAX值，并不断更新</li><li>返回结果</li></ol><h4 id="伪代码-1">伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">SOLVE</span>():<br>    max_value = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> <span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> <span class="hljs-number">10</span>:<br>            max_value = <span class="hljs-built_in">max</span>(max_value, GET_DISTANCE(p[i], p[j]))<br>    <span class="hljs-keyword">return</span> max_value<br></code></pre></td></tr></table></figure><h3 id="分治优化">2、分治优化</h3><h4 id="思路-2">思路</h4><ol type="1"><li>首先将所有点按照X轴坐标排序</li><li>对于排序好的点，平分成两个子集<ul><li>若该子集中只有不超过三个点，则使用暴力法算出最近距离</li><li>否则继续分成两个子集</li></ul></li><li>经过上述操作分别得到左右点集中的最短点对距离，并取其中的最小值记为w</li><li>对于点集分界线两侧w宽度区域内的点，按照y轴进行排序</li><li>遍历排序后的点，分别计算它与其他点的距离，并与w比较，取最小值</li><li>返回w</li></ol><h4 id="伪代码-2">伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">SORT_BY_X(P)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">FIND</span>(<span class="hljs-params">P, l, r</span>):<br>    <span class="hljs-keyword">if</span> P[l:r].size &lt;= <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> GET_MIN(P)<br>    <span class="hljs-keyword">else</span>:<br>        w1 = FIND(P, l, (l+r)/<span class="hljs-number">2</span>)<br>        w2 = FIND(P, (l+r)/<span class="hljs-number">2</span>, r)<br>        <br>        w = <span class="hljs-built_in">min</span>(w1, w2)<br>        <br>        P_new = P[(l+r)/<span class="hljs-number">2</span>-w:(l+r)/<span class="hljs-number">2</span>+w]<br>        SORT_BY_Y(P_new)<br>        <br>        <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> P_new:<br>            h = GET_DIS(point, P_new)<br>            w = <span class="hljs-built_in">min</span>(w, h)<br>        <br>        <span class="hljs-keyword">return</span> w<br></code></pre></td></tr></table></figure><h4 id="时间复杂度-1">时间复杂度：</h4><p>最开始需要进行一次全体排序，时间复杂度为<span class="math inline">\(O(n\log{n})\)</span>，之后FIND部分，包含两个递归调用和一次排序、一次遍历： <span class="math display">\[ T(n)= 2T(\frac{n}{2}) + O(n\log{n}) + O(n) = O(n\log^2{n}) \]</span></p><h2 id="q3">Q3</h2><h3 id="题目-2">题目</h3><p>Given an integer <span class="math inline">\(n\)</span>, where <span class="math inline">\(100 &lt; n &lt; 10000\)</span>, please design an efficient algorithm to calculate <span class="math inline">\(3^n\)</span>, with a time complexity not exceeding <span class="math inline">\(O(n)\)</span>.</p><ol type="1"><li>Implement a naive calculation method to compute <span class="math inline">\(3^n\)</span> and analyze the time complexity of the naive calculation method.</li><li>Propose an improved algorithm to calculate 3n with a time complexity not exceeding <span class="math inline">\(O(n)\)</span>. Describe the algorithm’s concept and analyze its time complexity</li></ol><h3 id="暴力解-1">1、暴力解</h3><h4 id="思路-3">思路</h4><p>对于输入的n，直接进行一个N次循环，每次*3</p><h4 id="伪代码-3">伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">CAL</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> n:<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><h4 id="时间复杂度-2">时间复杂度</h4><p>由于仅有一个循环，且循环内仅有一次操作，故总的时间复杂度为<span class="math inline">\(O(n)\)</span></p><h3 id="优化">2、优化</h3><h4 id="思路-4">思路</h4><ul><li>若n为0，直接返回1</li><li>若n为偶数，则<span class="math inline">\(3^n=(3^{\frac{n}{2}})^2\)</span></li><li>若n为奇数，则<span class="math inline">\(3^n=3^{n-1}\times3\)</span></li></ul><h4 id="伪代码-4">伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">CAL</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> CAL(n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> CAL(n-<span class="hljs-number">1</span>)*<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="时间复杂度-3">时间复杂度</h4><p>每次递归需要的运算为平方、乘法，时间复杂度均为<span class="math inline">\(O(1)\)</span>，递归次数为 <span class="math inline">\(\log n\)</span>，因此时间复杂度为 <span class="math display">\[ T(n) = \begin{cases} 1 &amp; n = 0 \\ T(\frac{n}{2}) + c = O() &amp; n\neq 0 \end{cases} \]</span></p><h2 id="q4">Q4</h2><h3 id="题目-3">题目</h3><p>Given a binary tree T, please give an <span class="math inline">\(O(n)\)</span> algorithm to invert binary tree. For example below, inverting the left binary tree, we get the right binary tree.</p><h3 id="思路-5">思路</h3><ul><li>对于每一个节点的左右孩子，分两种情况：<ul><li>是叶子节点，下一步</li><li>不是叶子节点，递归调用</li></ul></li><li>两个子节点处理结束之后，对换左右孩子</li></ul><h3 id="伪代码-5">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">INVERT</span>(<span class="hljs-params">Node N</span>):<br>    <span class="hljs-keyword">if</span> N.L是叶子节点 &amp;&amp; N.R是叶子节点:<br>        swap(N.L, N.R)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> N.L是叶子节点:<br>            INVERT(N.L)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> N.R是叶子节点:<br>            INVERT(N.R)<br><br>        swap(N.L, N.R)<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-4">时间复杂度</h3><p>每一次递归中进行的运算为交换左右孩子，时间夫复杂度为<span class="math inline">\(O(1)\)</span>，递归调用的次数等于节点数，因此时间复杂度为<span class="math inline">\(O(n)\)</span></p><h2 id="q5">Q5</h2><h3 id="题目-4">题目</h3><p>There are <span class="math inline">\(N\)</span> rooms in a prison, one for each prisoner, and there are <span class="math inline">\(M\)</span> religions, and each prisoner will follow one of them. If the prisoners in the adjacent room are of the same religion, escape may occur. Please give an <span class="math inline">\(O(n)\)</span> algorithm to find out how many states escape can occur. For example, there are 3 rooms and 2 kinds of religions, then 6 different states escape will occur.</p><h3 id="思路-6">思路</h3><p>由于直接计算会越狱的情况比较复杂，转而求出总的情况和不会越狱的情况，相减得到会越狱的数量。</p><p>对于不会越狱，实际上就是要求相邻两个牢房的宗教信仰不一样即可，设第一间房间有m种可能，则他的相邻房间不会越狱的可选情况有m-1种，再相邻的依旧。因此实际上是求 <span class="math display">\[ m^n - m(m-1)^{n-1} \]</span> 而求幂函数在Q3中已经有优化方法，这里直接使用</p><h3 id="伪代码-6">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">SQUARING</span>(<span class="hljs-params">m, n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> SQUARING(n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> SQUARING(n-<span class="hljs-number">1</span>)*m<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">CAL</span>(<span class="hljs-params">M, N</span>):<br>    <span class="hljs-built_in">sum</span> = SQUARING(M, N)<br>    success = SQUARING(M-<span class="hljs-number">1</span>, N-<span class="hljs-number">1</span>) * M<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> - success<br>    <br></code></pre></td></tr></table></figure><h3 id="时间复杂度-5">时间复杂度</h3><p>核心操作为两次幂运算，每次的时间复杂度均为<span class="math inline">\(\log{n}\)</span>，故总的时间复杂度仍然为<span class="math inline">\(\log{n}\)</span></p><p><span class="math display">\[ T(n) = 2T(\frac{n}{2}) + O(1) = O(\log{n}) \]</span></p><h1 id="二动态规划">二、动态规划</h1><h2 id="q1-money-robbing">Q1 Money Robbing</h2><h3 id="题目-5">题目</h3><p>A robber is planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><ol type="1"><li>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</li><li>What if all houses are arranged in a circle?</li></ol><h3 id="普通解">1、普通解</h3><h4 id="思路-7">思路</h4><ul><li><strong>状态</strong>：每一个房子有两种状态，抢劫或不抢，i表示第i个房子</li><li><strong>状态转移方程</strong>：</li></ul><p><span class="math display">\[ dp[i] = \max \begin{cases} money_i+dp[i-2]\\ dp[i-1] \end{cases} \]</span></p><ul><li><strong>初始状态</strong>：<ul><li>dp[0]=0</li><li>dp[1]=1</li></ul></li><li><strong>计算顺序</strong>：采用自底向上的方式，一直计算到dp[n]，其值即为所求最大值</li></ul><h4 id="伪代码-7">伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">function robHouses(money):<br>    n = length(money)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> money[<span class="hljs-number">1</span>]<br><br>    dp = new Array(n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp[<span class="hljs-number">1</span>] = money[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">2</span> to n:<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>] + money[i])<br><br>    <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h4 id="时间复杂度-6">时间复杂度</h4><p>子问题的个数为n，每一个问题的求解时间为1，因此此算法的时间复杂度为O(n)</p><h3 id="环形街道">2、环形街道</h3><h4 id="分析">分析</h4><p>相比较于原题，当街道是环形时，将整个问题分为两个小的子问题：不抢第一个房子和不抢最后一个房子，在这两个情况下分别DP求出最优解，取其中较大的一个作为答案即可。</p><h4 id="伪代码-8">伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">function robHouses(money): <br>    n = length(money) <br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <br>        <span class="hljs-keyword">return</span> money[<span class="hljs-number">0</span>]<br><br>    // 不抢劫第一座房子的情况<br>    dp1[<span class="hljs-number">1</span>] = money[<span class="hljs-number">0</span>]<br><br>    // 不抢劫最后一座房子的情况<br>    dp2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    dp2[<span class="hljs-number">1</span>] = money[<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to n-<span class="hljs-number">1</span>:<br>        dp1[i] = <span class="hljs-built_in">max</span>(dp1[i-<span class="hljs-number">1</span>], dp1[i-<span class="hljs-number">2</span>] + money[i])<br><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">2</span> to n:<br>        dp2[i] = <span class="hljs-built_in">max</span>(dp2[i-<span class="hljs-number">1</span>], dp2[i-<span class="hljs-number">2</span>] + money[i])<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp1[n-<span class="hljs-number">1</span>], dp2[n])<br></code></pre></td></tr></table></figure><h4 id="时间复杂度-7">时间复杂度</h4><p>虽然拆分成了两个子问题，但是时间复杂度仍然为O(n)</p><h2 id="q2-ugly-number">Q2 Ugly Number</h2><h3 id="题目-6">题目</h3><h3 id="暴力解-2">1、暴力解</h3><h4 id="思路-8">思路</h4><p>直接从1开始遍历所有自然数，并判断每一个数是否为丑数。具体方法为一直除2、3、5，并看最后余数是否为1</p><p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer <span class="math inline">\(n\)</span>, return the <span class="math inline">\(n^{th}\)</span> ugly number.</p><ol type="1"><li>Using a brute-force algorithm to solve this problem, analyze the time complexity of your implemented brute-force algorithm and explain why the algorithm’s time complexity is <span class="math inline">\(O(n^2)\)</span>, where <span class="math inline">\(n\)</span> is the number of points.</li><li>Propose an improved algorithm to solve this problem with a time complexity better than the brute-force algorithm. Describe the algorithm’s idea and analyze its time complexity.</li></ol><h4 id="伪代码-9">伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">function is_ugly(num):<br>    <span class="hljs-keyword">while</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        num /= <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:<br>        num /= <span class="hljs-number">3</span><br>    <span class="hljs-keyword">while</span> num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>        num /= <span class="hljs-number">5</span><br>    <span class="hljs-keyword">return</span> num == <span class="hljs-number">1</span><br><br>function nth_ugly_number(n):<br>    count = <span class="hljs-number">0</span><br>    num = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> count &lt; n:<br>        <span class="hljs-keyword">if</span> is_ugly(num):<br>            count += <span class="hljs-number">1</span><br>        num += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> num - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="动态规划">2、动态规划</h3><h4 id="思路-9">思路</h4><ul><li><strong>状态</strong>：对于每一个数，它必然是由<span class="math inline">\(2^{p_2}\times 3^{p_3} \times 5^{p_5}\)</span>所组成的，即在之前的某个丑数的基础上乘以2、3或5得到</li><li><strong>状态转移方程</strong></li></ul><p><span class="math display">\[ dp[i] = \min \begin{cases} dp[p2] * 2\\ dp[p3] * 3\\ dp[p5] * 5 \end{cases} \]</span></p><ul><li><strong>初始状态</strong>：初始时p2=p3=p5=1，dp[0] = 1</li><li><strong>计算顺序</strong>：从1开始，逐个递推，每次将选中的<span class="math inline">\(p_i\)</span>更新为它要指向的下一个要乘以i的丑数，dp[n]即为第n个丑数</li></ul><h4 id="伪代码-10">伪代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">function nth_ugly_number(n):<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    p2, p3, p5 = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">2</span> to n：<br>        next_ugly = <span class="hljs-built_in">min</span>(dp[p2] * <span class="hljs-number">2</span>, dp[p3] * <span class="hljs-number">3</span>, dp[p5] * <span class="hljs-number">5</span>)<br>        dp[i] = next_ugly<br><br>        <span class="hljs-keyword">if</span> next_ugly == dp[p2] * <span class="hljs-number">2</span>：<br>            p2++<br>        <span class="hljs-keyword">elif</span> next_ugly == dp[p3] * <span class="hljs-number">3</span>：<br>            p3++<br>        <span class="hljs-keyword">elif</span> next_ugly == dp[p5] * <span class="hljs-number">5</span>：<br>            p5++<br><br>    <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h4 id="时间复杂度-8">时间复杂度</h4><p>子问题的个数为N-1，每次运算的复杂度为常数级，不存在递归调用，因此总的时间复杂度为O(n)</p><h2 id="q3-unique-binary-search-trees">Q3 Unique Binary Search Trees</h2><h3 id="题目-7">题目</h3><p>Given <span class="math inline">\(n\)</span>, how many structurally unique BST’s (binary search trees) that store values 1...n?</p><p>Note: Given <span class="math inline">\(n = 3\)</span>, there are a total of 5 unique BST’s</p><h3 id="思路-10">思路</h3><ul><li><p><strong>状态</strong>：用dp[i]表示取i为二叉树的根，则可以将全部的数字分为[1:i-1]和[i+1:n]两部分，分别属于左右子树</p></li><li><p><strong>状态转移方程</strong>：每一个根确定的情况下，通过累加求得右子树乘以左子树的值</p></li></ul><p><span class="math display">\[ dp[i] = \sum_{j=1}^i\left(dp[j-1]\times dp[i-j]\right) \]</span></p><ul><li><strong>初始状态</strong>：显然，dp[0]=dp[1]=1</li><li><strong>计算顺序</strong>：从2开始循环遍历直到n，dp[n]的值即为所求结果</li></ul><h3 id="伪代码-11">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">function numTrees(n):<br>    dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">2</span> to n:<br>        dp[i] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to i:<br>            dp[i] += dp[j-<span class="hljs-number">1</span>] * dp[i-j]<br><br>    <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-9">时间复杂度</h3><p>本题外层循环n-1次，对于每个内层，循环的次数为<span class="math inline">\(\sum i\)</span>，因此，总的时间复杂度为<span class="math inline">\(O(n^2)\)</span></p><h2 id="q4-largest-divisible-subset">Q4 Largest Divisible Subset</h2><h3 id="题目-8">题目</h3><p>Given a set of distinct positive integers, find the largest subset such that every pair <span class="math inline">\((S_i, S_j)\)</span> of elements in this subset satisfies: <span class="math inline">\(S_i\%S_j = 0\)</span> or <span class="math inline">\(S_j\%S_i = 0\)</span>. Please return the largest size of the subset.</p><p>Note: <span class="math inline">\(S_i\%S_j = 0\)</span> means that <span class="math inline">\(S_i\)</span> is divisible by <span class="math inline">\(S_j\)</span>.</p><h3 id="思路-11">思路</h3><ul><li><strong>状态</strong>：首先假设所给集合为升序排列，用dp[i]表示以第i个数结尾的最大子集大小</li><li><strong>转移方程</strong>：对于每一个数字num[i]，若它可以被某个小于它的数num[j]整除，则它也一定可以被能够整除num[j]的所有数整除，即有</li></ul><p><span class="math display">\[ dp[i] = \max \begin{cases} dp[i]\\ dp[j] + 1 \end{cases} \]</span></p><ul><li><strong>初始状态</strong>：初始化所有dp[i]=1，因为显然数字自己成为一个子集</li></ul><h3 id="伪代码-12">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">function largestSubset(nums):<br>	maxSize = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">from</span> <span class="hljs-number">1</span> to n-<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">from</span> <span class="hljs-number">0</span> to i:<br>            <span class="hljs-keyword">if</span> nums[j] % nums[i] == <span class="hljs-number">0</span>:<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>)<br><br>        maxSize = <span class="hljs-built_in">max</span>(dp[i], maxSize)<br><br>    <span class="hljs-keyword">return</span> maxSize<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-10">时间复杂度</h3><p>本题中，外层循环的次数为n-1，内层次数为<span class="math inline">\(\sum i\)</span>，因此总的时间复杂度为<span class="math inline">\(O(n^2)\)</span></p><h2 id="q5-target-sum">Q5 Target Sum</h2><h3 id="题目-9">题目</h3><p>You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols ’+’ and ’-’ before each integer in nums and then concatenate all the integers.</p><p>For example, if nums = [2, 1], you can add a ’+’ before 2 and a ’-’ before 1 and concatenate them to build the expression ”+2-1”.</p><p>Return the number of different expressions that you can build, which evaluates to target.</p><p>Example:</p><ul><li><strong>Input</strong>: nums = [1,1,1,1,1], target = 3</li><li><strong>Output</strong>: 5</li><li><strong>Explanation</strong>: There are 5 ways to assign symbols to make the sum of nums be target 3.</li></ul><p><span class="math display">\[ -1 + 1 + 1 +1+1=3\\ +1- 1 + 1 +1+1=3\\ +1 + 1- 1 +1+1=3\\ +1 + 1 +1-1+1=3\\ +1 + 1 +1+1-1=3 \]</span></p><h3 id="思路-12">思路</h3><p>对于每一个数字而言，只有+和-两种选择，那么假设所有加的数为一个集合S1，则剩下的数必然属于减去的集合S2。显然，有 <span class="math display">\[ \begin{align} target &amp;= \sum S1_{i} - \sum S2_i \\ &amp;= \sum S_i - 2\sum S2_i \end{align} \]</span> 即： <span class="math display">\[ \sum S2_i = \frac{\sum S - target}{2} \]</span> 则所求问题变为：从全集S中挑选n个数，组成一个集合S2，使得S2的求和等于S的总和减去target</p><ul><li><strong>状态</strong>：取<span class="math inline">\(dp[i][j]\)</span>表示对于前i个数，和为j的方案数</li><li><strong>转移方程</strong>：令S2的求和等于S的总和减去target的值为diff，则对于小于diff的每一个j，计算<span class="math inline">\(dp[i][j]\)</span>。显然，要想取这个数，j必然大于等于<span class="math inline">\(num[i]\)</span>，因此有</li></ul><p><span class="math display">\[ dp[i]= \begin{cases} dp [i-1][j] &amp; j &lt; nums[i]\\ dp[i-1][j] + dp[i-1][j-nums[i]] &amp; j\geq nums[i] \end{cases} \]</span></p><ul><li><strong>初始状态</strong>：当S为空集时，和为0，方案数为1（即什么都不选），因此<span class="math inline">\(dp[0][0]=1\)</span></li></ul><h3 id="伪代码-13">伪代码</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function <span class="hljs-built_in">findTargetSumWays</span>(nums<span class="hljs-selector-attr">[]</span>, target): <br>	sum = <span class="hljs-number">0</span> <br>	<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums: <br>		sum += num <br>    diff = (sum - target)/<span class="hljs-number">2</span> <br>    <br>    dp<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-attr">[0]</span> = <span class="hljs-number">1</span> <br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> to n: <br>    	num = nums<span class="hljs-selector-attr">[i - 1]</span> <br>    	<span class="hljs-keyword">for</span> j = <span class="hljs-number">0</span> to diff: <br>    		dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> <br>    		<span class="hljs-keyword">if</span> j &gt;= num: <br>    			dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> += dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j - num]</span> <br>    return dp<span class="hljs-selector-attr">[n]</span><span class="hljs-selector-attr">[diff]</span><br></code></pre></td></tr></table></figure><h3 id="时间复杂度-11">时间复杂度</h3><p>最开始求和，需要O(n)的时间，主体部分，外层循环n次，内层循环diff次，因此总的时间复杂度为<span class="math inline">\(O(n \times diff)\)</span></p><h1 id="三贪心">三、贪心</h1><h2 id="q1-commando-war">Q1 Commando War</h2><h3 id="题目-10">题目</h3><p>There is a war and it doesn’t look very promising for your country. Now it’s time to act. You have a commando squad at your disposal and planning an ambush on an important enemy camp located nearby. You have N soldiers in your squad. In your master-plan, every single soldier has a unique responsibility and you don’t want any of your soldier to know the plan for other soldiers so that everyone can focus on his task only. In order to enforce this, you brief every individual soldier about his tasks separately and just before sending him to the battlefield. You know that every single soldier needs a certain amount of time to execute his job. You also know very clearly how much time you need to brief every single soldier. Being anxious to finish the total operation as soon as possible, you need to find an order of briefing your soldiers that will minimize the time necessary for all the soldiers to complete their tasks. You may assume that, no soldier has a plan that depends on the tasks of his fellows. In other words, once a soldier begins a task, he can finish it without the necessity of pausing in between.</p><p><strong>Input</strong>: There will be multiple test cases in the input file. Every test case starts with an integer N<span class="math inline">\((1 \leq N \leq 1000)\)</span>, denoting the number of soldiers. Each of the following N lines describe a soldier with two integers B(1 &lt;= B &lt;= 10000)&amp;J(1 &lt;= J &lt;= 10000). B seconds are needed to brief the soldier while completing his job needs J seconds. The end of input will be denoted by a case with N = 0 . This case should not be processed.</p><p><strong>Output</strong>: For each test case, print a line in the format, “Case X: Y”, where X is the case number &amp;Y is the total number of seconds counted from the start of your first briefing till the completion of all jobs.</p><h3 id="思路-13">思路</h3><p><strong>贪心规则</strong>：优先选择所需时间最长的工作</p><ul><li>所需时间相同时，先选择安排工作时间长的</li></ul><h2 id="伪代码-14">伪代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">function briefingTime(soldiers)<br>    sort soldiers by B <span class="hljs-keyword">in</span> ascending order<br><br>    totalBriefingTime = <span class="hljs-number">0</span><br>    totalTime = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to N<br>        totalTime += soldiers[i].B<br>        totalBriefingTime = <span class="hljs-built_in">max</span>(totalTime + soldiers[i].J, totalBriefingTime)<br><br>    <span class="hljs-keyword">return</span> totalBriefingTime<br></code></pre></td></tr></table></figure><h2 id="时间复杂度-12">时间复杂度</h2><p>首先需要进行一个排序，所需时间复杂度为<span class="math inline">\(O(n\log n)\)</span>，接下来进行了一层遍历，每次遍历中进行的运算为常数级，故总的时间复杂度为<span class="math inline">\(O(n\log n)\)</span></p><h2 id="q2-dna-consensus-string">Q2 DNA Consensus String</h2><h3 id="题目-11">题目</h3><p>The Hamming distance is the number of different characters at each position from two strings of equal length. For example, assume we are given the two strings “AGCAT” and “GGAAT.” The Hamming distance of these two strings is 2 because the 1st and the 3rd characters of the two strings are different. Using the Hamming distance, we can define a representative string for a set of multiple strings of equal length. Given a set of strings <span class="math inline">\(S = \{s_1,\dots,s_m\}\)</span> of length n, the consensus error between a string y of length n and the set S is the sum of the Hamming distances between y and each si in S. If the consensus error between y and S is the minimum among all possible strings y of length n, y is called a consensus string of S. For example, given the three strings “AGCAT” “AGACT” and “GGAAT” the consensus string of the given strings is “AGAAT” because the sum of the Hamming distances between “AGAAT” and the three strings is 3 which is minimal. (In this case, the consensus string is unique, but in general, there can be more than one consensus string.) We use the consensus string as a representative of the DNA sequence. For the example of Figure 1 above, a consensus string of gene X is “GCAAATGGCTGTGCA” and the consensus error is 7. <span class="math display">\[ \begin{array}{l|l} &amp; \text { DNA sequence of gene X } \\ \hline \text { Cat: } &amp; \text { GCATATGGCTGTGCA } \\ \text { Dog: } &amp; \text { GCAAATGGCTGTGCA } \\ \text { Horse: } &amp; \text { GCTAATGGGTGTCCA } \\ \text { Cow: } &amp; \text { GCAAATGGCTGTGCA } \\ \text { Monkey: } &amp; \text { GCAAATCGGTGAGCA } \end{array} \]</span> <strong>Input</strong>: Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the input. Each test case starts with a line containing two integers m and n which are separated by a single space. The integer <span class="math inline">\(m(4 \leq m \leq 50)\)</span> represents the number of DNA sequences and <span class="math inline">\(n(4 \leq n \leq 1000)\)</span> represents the length of the DNA sequences, respectively. In each of the next m lines, each DNA sequence is given.</p><p><strong>Output</strong>: Your program is to write to standard output. Print the consensus string in the first line of each case and the consensus error in the second line of each case. If there exists more than one consensus string, print the lexicographically smallest consensus string.</p><h3 id="思路-14">思路</h3><p><strong>贪心规则</strong>：对于每一位上的字母，统计输入的各个字符串，得到每一位上出现频次最高的字母，若有相同则按照字典序取较低的（对于本题即A-C-G-T）</p><h3 id="伪代码-15">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">function consensus(sequences):<br>    result = <span class="hljs-string">&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to <span class="hljs-built_in">len</span>(sequences[<span class="hljs-number">0</span>]):<br>        charMap = createEmptyMap()<br>        <br>        <span class="hljs-keyword">for</span> sequence <span class="hljs-keyword">in</span> sequences:<br>            charMap.put(sequence[i], charMap.get(sequence[i]))<br>            <br>        sort charMap by value <span class="hljs-keyword">in</span> ascending order<br>        result += charMap.get(<span class="hljs-number">0</span>).key<br>        <br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-13">时间复杂度</h3><p>外层循环有n次，即每个序列的长度；内层循环有m次，即序列的数量。每一次外层循环中包含m次map读写以及一次排序，即<span class="math inline">\(m + O(4 \log 4)\)</span>，由于实际上只有4中碱基，因此排序的元素永远只有四个，这一步可以认为是常数级别。故总时间复杂度为<span class="math inline">\(O(nm)\)</span></p><h2 id="q3-opponents">Q3 Opponents</h2><h3 id="题目-12">题目</h3><p>Arya has n opponents in the school. Each day he will fight with all opponents who are present this day. His opponents have some fighting plan that guarantees they will win, but implementing this plan requires presence of them all. That means if one day at least one of Arya’s opponents is absent at the school, then Arya will beat all present opponents. Otherwise, if all opponents are present, then they will beat Arya.</p><p>For each opponent Arya knows his schedule — whether or not he is going to present on each particular day. Tell him the maximum number of consecutive days that he will beat all present opponents.</p><p>Note that if some day there are no opponents present, Arya still considers he beats all the present opponents.</p><p><strong>Input</strong>: The first line of the input contains two integers <span class="math inline">\(n\)</span> and <span class="math inline">\(d ( 1\leq n,d \leq 100 )\)</span> — the number of opponents and the number of days, respectively. The i-th of the following d lines contains a string of length n consisting of characters ’0’ and ’1’. The j-th character of this string is ’0’ if the j-th opponent is going to be absent on the i-th day.</p><p><strong>Output</strong>: Print the only integer — the maximum number of consecutive days that Arya will beat all present opponents.</p><h3 id="思路-15">思路</h3><ul><li><strong>分析</strong>：每天有两种情况，对手到齐或没有到齐，也就是对应着赢或输</li><li><strong>贪心规则</strong>：统计当前连胜天数，并与历史连胜天数比较，取其中最大的即可</li></ul><h3 id="伪代码-16">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">function win(opponents):<br>    max_win = <span class="hljs-number">0</span><br>    now_win = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span> to <span class="hljs-built_in">len</span>(opponents):<br>        <span class="hljs-keyword">if</span> opponents[i] == <span class="hljs-number">1</span>:<br>            now_win = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            now_win += <span class="hljs-number">1</span><br>            max_win = <span class="hljs-built_in">max</span>(max_win, now_win)<br>    <br>    <span class="hljs-keyword">return</span> max_win<br></code></pre></td></tr></table></figure><h3 id="时间复杂度-14">时间复杂度</h3><p>仅需要一次遍历即可得出结果，因此时间复杂度为<span class="math inline">\(O(n)\)</span></p><h2 id="q4-minimum-varied-number">Q4 Minimum Varied Number</h2><h3 id="题目-13">题目</h3><p>Find the minimum number with the given sum of digits s such that all digits in it are distinct (i.e. all digits are unique).</p><p>For example, if s = 20 , then the answer is 389 . This is the minimum number in which all digits are different and the sum of the digits is 20 ( 3+8+9 = 20 ).</p><p>For the given s print the required number.</p><p><strong>Input</strong>: The first line contains an integer <span class="math inline">\(t ( 1 \leq t \leq 45 )\)</span> — the number of test cases. Each test case is specified by a line that contains the only integer <span class="math inline">\(s ( 1 \leq s \leq 45 )\)</span>.</p><p><strong>Output</strong>: Print t integers — the answers to the given test cases.</p><h3 id="思路-16">思路</h3><ul><li><strong>分析</strong>：实际上就是需要在1到9的数字间选取最少的数使得和为S，那么从大到小选取即可</li><li><strong>贪心规则</strong><ul><li>若s小于等于9，则结果就是s本身</li><li>若s大于9，则从9开始遍历，依次加上能加的最大数</li></ul></li></ul><h3 id="伪代码-17">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">MIN_NUMBER</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> s</span>):<br>    result = <span class="hljs-string">&#x27;&#x27;</span><br>    last_max = <span class="hljs-number">9</span><br>    <br>    <span class="hljs-keyword">while</span> s&gt;last_max:<br>        s -= last_max<br>        result = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;last_max&#125;</span><span class="hljs-subst">&#123;result&#125;</span>&#x27;</span><br>        last_max--<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;s&#125;</span><span class="hljs-subst">&#123;result&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="时间复杂度-15">时间复杂度</h3><p>由于这一算法必然能够在9次以内得到结果，因此时间复杂度为<span class="math inline">\(O(C)\)</span></p><h2 id="q5-joey-takes-money">Q5 Joey Takes Money</h2><p>Joey is low on money. His friend Chandler wants to lend Joey some money, but can’t give him directly, as Joey is too proud of himself to accept it. So, in order to trick him, Chandler asks Joey to play a game.</p><p>In this game, Chandler gives Joey an array <span class="math inline">\(a_1,a_2,\dots,a_n ( n \geq 2 )\)</span> of positive integers <span class="math inline">\(( a_i \geq 1 )\)</span>. Joey can perform the following operation on the array any number of times:</p><ol type="1"><li>Take two indices i and j <span class="math inline">\(( 1 \leq i &lt; j \leq n)\)</span> .</li><li>Choose two integers x and y <span class="math inline">\(( x,y \geq 1 )\)</span> such that <span class="math inline">\(x\cdot y =a_i \cdot a_j\)</span> .</li><li>Replace <span class="math inline">\(a_i\)</span> by <span class="math inline">\(x\)</span> and <span class="math inline">\(a_j\)</span> by <span class="math inline">\(y\)</span> .</li></ol><p>In the end, Joey will get the money equal to the sum of elements of the final array.</p><p>Find the maximum amount of money ans Joey can get but print <span class="math inline">\(2022 \cdot ans\)</span> . Why multiplied by 2022 ? Because we are never gonna see it again!</p><p>It is guaranteed that the product of all the elements of the array a doesn’t exceed <span class="math inline">\(10^{12}\)</span> .</p><p><strong>Input</strong>: Each test contains multiple test cases. The first line contains the number of test cases <span class="math inline">\(t ( 1 \leq t \leq 4000 )\)</span>. Description of the test cases follows. The first line of each test case contains a single integer <span class="math inline">\(n ( 2 \leq n \leq 50 )\)</span> — the length of the array a . The second line contains n integers <span class="math inline">\(a_1, a_2,\dots,a_n ( 1 \leq a_i \leq 10^6 )\)</span> — the array itself. It’s guaranteed that the product of all ai doesn’t exceed <span class="math inline">\(10^{12} (i. e. a_1 \cdot a_2 \cdot \dots \cdot a_n \leq 10^{12} )\)</span>.</p><p><strong>Output</strong>: For each test case, print the maximum money Joey can get multiplied by 2022 .</p><h3 id="思路-17">思路</h3><ul><li><strong>分析</strong>：<ul><li>这道题的目的就是对于array中的数对，选取它们的相等因子替换，使得得到的总和最大</li><li>而两个数相乘的所有因子中，合最大的就是1和乘积本身</li><li>因此依次将所有数全部换为乘积和1，则可以得到最大和</li></ul></li><li><strong>贪心规则</strong>：对所有数相乘即可</li></ul><h3 id="伪代码-18">伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">MAX_MONEY</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] array</span>):<br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> array:<br>        result *= num<br>    <span class="hljs-keyword">return</span> result + <span class="hljs-built_in">len</span>(array) - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="时间复杂度-16">时间复杂度</h3><p>由于仅需要一次遍历连乘，因此时间复杂度为<span class="math inline">\(O(n)\)</span></p><h1 id="四线性规划">四、线性规划</h1><h2 id="q1-1">Q1</h2><h3 id="题目-14">题目</h3><p>You want to determine the quantities <span class="math inline">\(x_1,x_2,\dots,x_n\)</span> of n different foods, each containing m types of nutrients. The amount of the i-th nutrient in the j-th food is represented as an, and the prices of the n foods are <span class="math inline">\(c_1,c_2,\dots,c_n\)</span>. Your goal is to find a recipe where the content of each of the m nutrients is at least <span class="math inline">\(b_1,b_2,\dots,b_m\)</span>, while minimizing the total cost.</p><h3 id="建模">建模</h3><p><span class="math display">\[ \begin{align} \min\ &amp;\sum_{i=1}^n c_ix_i \\ \text{s.t.}\ &amp;\sum_{j=1}^m a_{ij}x_{ij} - b_i \geq 0 &amp;i=1,2,\dots,m \\ &amp;x_i\geq 0 &amp; i=1,2,\dots,m \end{align} \]</span></p><h2 id="q2-1">Q2</h2><h3 id="题目-15">题目</h3><p>You now need to pack dormitory items. You have m items and n boxes, with enough boxes to accommodate all items. The space occupied by the i-th item is <span class="math inline">\(C_i\)</span>, and the capacity of the j-th box is <span class="math inline">\(S_j\)</span>. Your goal is to pack all items using as few boxes as possible.</p><h3 id="建模-1">建模</h3><p>这里设 <span class="math inline">\(x_{ij}\)</span> 表示第i个物品是否放在第j个盒子里，由于目标是使用尽可能少的盒子，因此对于每一列（即每个盒子）我们的希望是全部为零的列越多越好，则可以列出如下式子： $$ <span class="math display">\[\begin{align} \min &amp;\sum_{j=1}^{n} A_j \\ \text{s.t.}\ &amp; A_j = \begin{cases} 1 &amp; \sum\limits_{i=1}^{m} x_{ij} \neq 0 \\ 0 &amp; otherwise \end{cases} \\ &amp; \sum_i^m C_ix_{ij} - S_j \leq 0 &amp; j = 1,2,\dots,n \\ &amp;x_{ij} \in \{0,1\} \end{align}\]</span> $$</p><h2 id="q3-1">Q3</h2><h3 id="题目-16">题目</h3><p>On a farm, there are two different crops: wheat and soybeans. Planting one acre of wheat requires 5 units of fertilizer and 2 units of water, while planting one acre of soybeans requires 3 units of fertilizer and 4 units of water. The farm has 30 units of fertilizer and 20 units of water available. Each acre of wheat can be sold for 150 dollars, and each acre of soybeans can be sold for 120 dollars. The farm owner wants to maximize the total income.</p><h3 id="建模-2">建模</h3><p>设小麦和大豆分种植数量分别为<span class="math inline">\(x_1\)</span>和<span class="math inline">\(x_2\)</span>，则要求的是最大化收入，约束为使用的水和肥料不能超过农场的库存，则可以进行如下建模： <span class="math display">\[ \begin{align} \max\ &amp;150x_1+120x_2 \\ \text{s.t.}\ &amp;5x_1+3x_2 - 30 \leq 0 \\ &amp;2x_1 + 4x_2 - 20 \leq 0 \end{align} \]</span></p><h2 id="q4-1">Q4</h2><h3 id="题目-17">题目</h3><p>The company manufactures three products, A1, A2, and A3, utilizing resources such as metal sheets, labor, and machinery. The quantities of various resources required to manufacture one unit of each product are provided in the table below. Without considering fixed costs, the unit profits for each product are 40,000 yuan, 50,000 yuan, and 60,000 yuan, respectively. Available resources include 500 tons of metal sheets, 300 workers per month, and 100 machines per month. In addition to production, fixed costs must be paid: 1 million yuan for A1, 1.5 million yuan for A2, and 2 million yuan for A3. Develop a production plan for the company to maximize profits.</p><table><thead><tr class="header"><th style="text-align:center">Resources</th><th style="text-align:center">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">Metal sheets/t</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr class="even"><td style="text-align:center">Labor force (person/month)</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr class="odd"><td style="text-align:center">Machinery (units/month)</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><h3 id="建模-3">建模</h3><p>这道题存在一个fixed costs，但是题目中并没有表明它的缴费频率或者与是否生产对应成本有关，不过无论如何缴费，这这里我们都可以将fixed costs视为一个常数<span class="math inline">\(C_i\)</span>，因为它和产品的数量并无关系。</p><p>那么设三种产品生产数量分别为<span class="math inline">\(x_1\)</span>、<span class="math inline">\(x_2\)</span>、<span class="math inline">\(x_3\)</span>，则可以进行如下建模： <span class="math display">\[ \begin{align} \max\ &amp; 40000x_1+50000x_2+60000x_3 -\sum_{i=1}^3C_ia_i \\ \text{s.t.}\ &amp;2x_1+4x_2+8x_3 - 500 \leq 0 \\ &amp;2x_1+3x_2+4x_3 - 300 \leq 0 \\ &amp;x_1+2x_2+3x_3 - 100 \leq 0 \\ &amp;a_i = \begin{cases} 0 &amp; x_i = 0 \\ 1 &amp; x_i \neq0 \end{cases}\quad ,i\in\{1,2,3\} \end{align} \]</span></p><h2 id="q5-1">Q5</h2><h3 id="题目-18">题目</h3><p>The company plans to open branches in four districts in the urban area, with a total of 10 locations to choose from. Taking into account the consumption levels and residential density of residents in each district, the following rules are established:</p><ul><li>In District 1, at most two points can be selected from <span class="math inline">\(A_1\)</span>, <span class="math inline">\(A_2\)</span>, and <span class="math inline">\(A_3\)</span>;</li><li>In District 2, at least one point must be selected from <span class="math inline">\(A_4\)</span> and <span class="math inline">\(A_5\)</span>;</li><li>In District 3, at least one point must be selected from <span class="math inline">\(A_6\)</span> and <span class="math inline">\(A_7\)</span>;</li><li>In District 4, at least two points must be selected from <span class="math inline">\(A_8\)</span>, <span class="math inline">\(A_9\)</span>, and <span class="math inline">\(A_{10}\)</span>.</li></ul><p>The investment and annual profit for each point <span class="math inline">\(A_j\)</span> vary depending on the location, as shown in the table below. The total investment of the company should not exceed 7.2 million yuan. Which sales points should be selected to maximize the company’s annual profit?</p><table><thead><tr class="header"><th style="text-align:center"></th><th style="text-align:center">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th><th style="text-align:center">A4</th><th style="text-align:center">A5</th><th style="text-align:center">A6</th><th style="text-align:center">A7</th><th style="text-align:center">A8</th><th style="text-align:center">A9</th><th style="text-align:center">A10</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">Investment</td><td style="text-align:center">100</td><td style="text-align:center">120</td><td style="text-align:center">150</td><td style="text-align:center">80</td><td style="text-align:center">70</td><td style="text-align:center">90</td><td style="text-align:center">80</td><td style="text-align:center">140</td><td style="text-align:center">160</td><td style="text-align:center">180</td></tr><tr class="even"><td style="text-align:center">Profit</td><td style="text-align:center">36</td><td style="text-align:center">40</td><td style="text-align:center">50</td><td style="text-align:center">22</td><td style="text-align:center">20</td><td style="text-align:center">30</td><td style="text-align:center">25</td><td style="text-align:center">48</td><td style="text-align:center">58</td><td style="text-align:center">61</td></tr></tbody></table><h3 id="建模-4">建模</h3><p>对于这道题，设<span class="math inline">\(x_i\)</span>为是否选择<span class="math inline">\(A_i\)</span>，是则为1，否则为0。为了方便起见，设每一点的Investment为<span class="math inline">\(I_i\)</span>，Profit为<span class="math inline">\(P_i\)</span>则可以进行如下建模： <span class="math display">\[ \begin{align} \max\ &amp;\sum_{i=1}^{10}P_i\times x_i \\ \text{s.t.}\ &amp;\sum_{i=1}^{10}x_i = 4 \\ &amp;x_1+x_2+x_3 \leq 2 \\ &amp;x_4+x_5 \geq 1 \\ &amp;x_6+x_7 \geq 1 \\ &amp;x_8+x_9+x_{10} \geq 2 \\ &amp;\sum_{i=1}^{10} I_i \times x_i \leq 7200000 \\ &amp;x_i \in \{0,1\} \end{align} \]</span></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a></div></div><div class="license-box my-3"><div class="license-title"><div>算法设计与分析作业</div><div>https://www.aye10032.com/2024/01/13/2024-01-13-algorithm/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Aye10032</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年1月13日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2024/01/08/2024-01-08-bioinfo/" title="生物信息学复习"><span class="hidden-mobile">生物信息学复习</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="gitalk-container"></div><script type="text/javascript">Fluid.utils.loadComments("#gitalk-container",(function(){Fluid.utils.createCssLink("/css/gitalk.css"),Fluid.utils.createScript("https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js",(function(){var e=Object.assign({clientID:"eeda953af44e09f78441",clientSecret:"cb84da4697fdc74e72451e5b9618297b1667988b",repo:"Aye10032.github.io",owner:"Aye10032",admin:["Aye10032"],language:"zh-CN",labels:["Gitalk"],perPage:10,pagerDirection:"last",distractionFreeMode:!1,createIssueManually:!0,proxy:"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},{id:"305a3d63dd0990ec17cdc66981e5b299"});new Gitalk(e).render("gitalk-container")}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">苏ICP备19040408号-2 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=32108102010462" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" srcset="/images/loading.gif" lazyload alt="police-icon"> <span>苏公网安备 32108102010462号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>